/*
 * ShellEVLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.shell.api.controllers;

import com.shell.api.ApiHelper;
import com.shell.api.Server;
import com.shell.api.exceptions.ApiException;
import com.shell.api.exceptions.BadRequestException;
import com.shell.api.exceptions.InternalServerErrorException;
import com.shell.api.exceptions.NotFoundException;
import com.shell.api.exceptions.ServiceunavailableException;
import com.shell.api.exceptions.TooManyRequestsException;
import com.shell.api.exceptions.UnauthorizedException;
import com.shell.api.http.request.HttpMethod;
import com.shell.api.models.GetEVLocationsAuthorizationMethodsEnum;
import com.shell.api.models.GetEVLocationsConnectorTypesEnum;
import com.shell.api.models.GetEVLocationsEvseStatusEnum;
import com.shell.api.models.LocationsMarkersAuthorizationMethodsEnum;
import com.shell.api.models.LocationsMarkersConnectorTypesEnum;
import com.shell.api.models.LocationsMarkersEvseStatusEnum;
import com.shell.api.models.NearbyLocationsAuthorizationMethodsEnum;
import com.shell.api.models.NearbyLocationsConnectorTypesEnum;
import com.shell.api.models.NearbyLocationsEvseStatusEnum;
import com.shell.api.models.Response;
import com.shell.api.models.SingleLocationMarkerResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class LocationsController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public LocationsController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * This API provides the list of all Shell Recharge locations. The list includes all Shell
     * Recharge network and all locations available through our roaming partners. The end point
     * provides flexible search criteria in order to get the list of Shell Recharge Network. The end
     * point provides the details such as the exact location/address of the site along with the
     * up-to-date status information of all the charging units in the site. Supported Search Options
     * * Based on status of the Charging units. Eg : Available or Occupied * Based on available
     * connector types. * Based on minimum Power output (in kW) available * Based on a specific
     * charging unit ID (EVSE ID).
     * @param  requestId  Required parameter: RequestId must be unique identifier value that can be
     *         used by the consumer to correlate each request /response .&lt;br&gt;Format.&lt;br&gt;
     *         Its canonical textual representation, the 16 octets of a UUID are represented as 32
     *         hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the
     *         form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4
     *         hyphens) &lt;br&gt;
     * @param  evseStatus  Optional parameter: Filter by Locations that have the given status
     * @param  connectorTypes  Optional parameter: Filter by Locations that have Connectors with the
     *         set of Connector Types
     * @param  connectorMinPower  Optional parameter: Filter by Locations that have a Connector with
     *         at least this power output (in kW)
     * @param  authorizationMethods  Optional parameter: Filter by Locations that support the given
     *         Authorization Methods
     * @param  withOperatorName  Optional parameter: Return operator name in marker response object
     * @param  evseId  Optional parameter: optional Standard EVSE (Electric Vehicle Supply
     *         Equipment) Id identifier (ISO-IEC-15118)
     * @param  locationExternalId  Optional parameter: Filter by Locations with the given
     *         externalId. (Unique Location externalID provided by Shell Recharge)
     * @param  evseExternalId  Optional parameter: Filter by Locations that have an Evse with the
     *         given External Id. (Unique individual EVSE externalID provided by Shell Recharge)
     * @param  pageNumber  Optional parameter: Restrict the response list by providing a specific
     *         set of page Number. Set perPage parameter also when page Number is used.
     * @param  perPage  Optional parameter: Restrict the number of sites in response per page.
     * @param  updatedSince  Optional parameter: ZonedDateTime as string
     * @param  country  Optional parameter: Filter by Locations that are at least in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @param  excludeCountry  Optional parameter: Filter by Locations that are not in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @return    Returns the Response response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Response getEVLocations(
            final UUID requestId,
            final GetEVLocationsEvseStatusEnum evseStatus,
            final GetEVLocationsConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final GetEVLocationsAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final String evseId,
            final String locationExternalId,
            final String evseExternalId,
            final Integer pageNumber,
            final Integer perPage,
            final String updatedSince,
            final List<String> country,
            final List<String> excludeCountry) throws ApiException, IOException {
        return prepareGetEVLocationsRequest(requestId, evseStatus, connectorTypes,
                connectorMinPower, authorizationMethods, withOperatorName, evseId,
                locationExternalId, evseExternalId, pageNumber, perPage, updatedSince, country,
                excludeCountry).execute();
    }

    /**
     * This API provides the list of all Shell Recharge locations. The list includes all Shell
     * Recharge network and all locations available through our roaming partners. The end point
     * provides flexible search criteria in order to get the list of Shell Recharge Network. The end
     * point provides the details such as the exact location/address of the site along with the
     * up-to-date status information of all the charging units in the site. Supported Search Options
     * * Based on status of the Charging units. Eg : Available or Occupied * Based on available
     * connector types. * Based on minimum Power output (in kW) available * Based on a specific
     * charging unit ID (EVSE ID).
     * @param  requestId  Required parameter: RequestId must be unique identifier value that can be
     *         used by the consumer to correlate each request /response .&lt;br&gt;Format.&lt;br&gt;
     *         Its canonical textual representation, the 16 octets of a UUID are represented as 32
     *         hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the
     *         form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4
     *         hyphens) &lt;br&gt;
     * @param  evseStatus  Optional parameter: Filter by Locations that have the given status
     * @param  connectorTypes  Optional parameter: Filter by Locations that have Connectors with the
     *         set of Connector Types
     * @param  connectorMinPower  Optional parameter: Filter by Locations that have a Connector with
     *         at least this power output (in kW)
     * @param  authorizationMethods  Optional parameter: Filter by Locations that support the given
     *         Authorization Methods
     * @param  withOperatorName  Optional parameter: Return operator name in marker response object
     * @param  evseId  Optional parameter: optional Standard EVSE (Electric Vehicle Supply
     *         Equipment) Id identifier (ISO-IEC-15118)
     * @param  locationExternalId  Optional parameter: Filter by Locations with the given
     *         externalId. (Unique Location externalID provided by Shell Recharge)
     * @param  evseExternalId  Optional parameter: Filter by Locations that have an Evse with the
     *         given External Id. (Unique individual EVSE externalID provided by Shell Recharge)
     * @param  pageNumber  Optional parameter: Restrict the response list by providing a specific
     *         set of page Number. Set perPage parameter also when page Number is used.
     * @param  perPage  Optional parameter: Restrict the number of sites in response per page.
     * @param  updatedSince  Optional parameter: ZonedDateTime as string
     * @param  country  Optional parameter: Filter by Locations that are at least in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @param  excludeCountry  Optional parameter: Filter by Locations that are not in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @return    Returns the Response response from the API call
     */
    public CompletableFuture<Response> getEVLocationsAsync(
            final UUID requestId,
            final GetEVLocationsEvseStatusEnum evseStatus,
            final GetEVLocationsConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final GetEVLocationsAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final String evseId,
            final String locationExternalId,
            final String evseExternalId,
            final Integer pageNumber,
            final Integer perPage,
            final String updatedSince,
            final List<String> country,
            final List<String> excludeCountry) {
        try { 
            return prepareGetEVLocationsRequest(requestId, evseStatus, connectorTypes, connectorMinPower,
            authorizationMethods, withOperatorName, evseId, locationExternalId, evseExternalId,
            pageNumber, perPage, updatedSince, country, excludeCountry).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getEVLocations.
     */
    private ApiCall<Response, ApiException> prepareGetEVLocationsRequest(
            final UUID requestId,
            final GetEVLocationsEvseStatusEnum evseStatus,
            final GetEVLocationsConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final GetEVLocationsAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final String evseId,
            final String locationExternalId,
            final String evseExternalId,
            final Integer pageNumber,
            final Integer perPage,
            final String updatedSince,
            final List<String> country,
            final List<String> excludeCountry) throws IOException {
        return new ApiCall.Builder<Response, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/locations/v1/ev")
                        .queryParam(param -> param.key("evseStatus")
                                .value((evseStatus != null) ? evseStatus.value() : null).isRequired(false))
                        .queryParam(param -> param.key("connectorTypes")
                                .value((connectorTypes != null) ? connectorTypes.value() : null).isRequired(false))
                        .queryParam(param -> param.key("connectorMinPower")
                                .value(connectorMinPower).isRequired(false))
                        .queryParam(param -> param.key("authorizationMethods")
                                .value((authorizationMethods != null) ? authorizationMethods.value() : null).isRequired(false))
                        .queryParam(param -> param.key("withOperatorName")
                                .value(withOperatorName).isRequired(false))
                        .queryParam(param -> param.key("evseId")
                                .value(evseId).isRequired(false))
                        .queryParam(param -> param.key("locationExternalId")
                                .value(locationExternalId).isRequired(false))
                        .queryParam(param -> param.key("evseExternalId")
                                .value(evseExternalId).isRequired(false))
                        .queryParam(param -> param.key("pageNumber")
                                .value(pageNumber).isRequired(false))
                        .queryParam(param -> param.key("perPage")
                                .value(perPage).isRequired(false))
                        .queryParam(param -> param.key("updatedSince")
                                .value(updatedSince).isRequired(false))
                        .queryParam(param -> param.key("country")
                                .value(country).isRequired(false))
                        .queryParam(param -> param.key("excludeCountry")
                                .value(excludeCountry).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(String.valueOf(requestId)).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Response.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new BadRequestException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid authentication credentials for the target resource.",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("Location Not Found",
                                (reason, context) -> new NotFoundException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The Request reached maximum allocated rate limit",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal Server error",
                                (reason, context) -> new InternalServerErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service unavailable",
                                (reason, context) -> new ServiceunavailableException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API provides the details on a single Shell Recharge location. The query for a single
     * location is to be made using the Unique Internal identifier used to refer to this Location by
     * Shell Recharge. (Uid from List of locations API).
     * @param  requestId  Required parameter: RequestId must be unique identifier value that can be
     *         used by the consumer to correlate each request /response .&lt;br&gt;Format.&lt;br&gt;
     *         Its canonical textual representation, the 16 octets of a UUID are represented as 32
     *         hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the
     *         form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4
     *         hyphens) &lt;br&gt;
     * @param  id  Required parameter: Unique Uid of the location from List of locations API
     * @param  providerId  Optional parameter: The provider id that you wish to see locations and
     *         tariffs for
     * @param  since  Optional parameter: to get the locations modified after a date
     * @return    Returns the Response response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Response evLocationsByID(
            final UUID requestId,
            final String id,
            final String providerId,
            final String since) throws ApiException, IOException {
        return prepareEvLocationsByIDRequest(requestId, id, providerId, since).execute();
    }

    /**
     * This API provides the details on a single Shell Recharge location. The query for a single
     * location is to be made using the Unique Internal identifier used to refer to this Location by
     * Shell Recharge. (Uid from List of locations API).
     * @param  requestId  Required parameter: RequestId must be unique identifier value that can be
     *         used by the consumer to correlate each request /response .&lt;br&gt;Format.&lt;br&gt;
     *         Its canonical textual representation, the 16 octets of a UUID are represented as 32
     *         hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the
     *         form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4
     *         hyphens) &lt;br&gt;
     * @param  id  Required parameter: Unique Uid of the location from List of locations API
     * @param  providerId  Optional parameter: The provider id that you wish to see locations and
     *         tariffs for
     * @param  since  Optional parameter: to get the locations modified after a date
     * @return    Returns the Response response from the API call
     */
    public CompletableFuture<Response> evLocationsByIDAsync(
            final UUID requestId,
            final String id,
            final String providerId,
            final String since) {
        try { 
            return prepareEvLocationsByIDRequest(requestId, id, providerId, since).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for evLocationsByID.
     */
    private ApiCall<Response, ApiException> prepareEvLocationsByIDRequest(
            final UUID requestId,
            final String id,
            final String providerId,
            final String since) throws IOException {
        return new ApiCall.Builder<Response, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/locations/v1/ev/{id}")
                        .queryParam(param -> param.key("providerId")
                                .value(providerId).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(since).isRequired(false))
                        .templateParam(param -> param.key("id").value(id)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("RequestId")
                                .value(String.valueOf(requestId)).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Response.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new BadRequestException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid authentication credentials for the target resource.",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("Location Not Found",
                                (reason, context) -> new NotFoundException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The Request reached maximum allocated rate limit",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal Server error",
                                (reason, context) -> new InternalServerErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service unavailable",
                                (reason, context) -> new ServiceunavailableException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API provides the list of all nearby Shell Recharge locations based on the latitude and
     * longitude provided in the request. The list includes all Shell Recharge network and all sites
     * available through our roaming partners. The end point provides the details such as the exact
     * location/address of the site along with the up-to-date status information of all the charging
     * units in the site. Supported Search Options * Based on latitude and longitude of the
     * location. (Mandatory) * Based on status of the Charging units. Eg : Available or Occupied *
     * Based on available connector types. * Based on minimum Power output (in kW) available.
     * @param  requestId  Required parameter: RequestId must be unique identifier value that can be
     *         used by the consumer to correlate each request /response .&lt;br&gt;Format.&lt;br&gt;
     *         Its canonical textual representation, the 16 octets of a UUID are represented as 32
     *         hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the
     *         form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4
     *         hyphens) &lt;br&gt;
     * @param  latitude  Required parameter: Latitude to get Shell Recharge Locations nearby
     * @param  longitude  Required parameter: Longitude to get Shell Recharge Locations nearby
     * @param  limit  Optional parameter: Maximum number of Locations to retrieve
     * @param  locationExternalId  Optional parameter: Filter by Locations with the given externalId
     *         Identifier as given by the Shell Recharge Operator, unique for that Operator
     * @param  evseId  Optional parameter: Filter by Locations that have an Evse with the given Evse
     *         Id
     * @param  evseExternalId  Optional parameter: Filter by Locations that have an Evse with the
     *         given External Id Identifier of the Evse as given by the Operator, unique for that
     *         Operator
     * @param  operatorName  Optional parameter: Filter by Locations that have the given operator
     * @param  evseStatus  Optional parameter: Filter by Locations that have the given status
     * @param  connectorTypes  Optional parameter: Filter by Locations that have Connectors with
     *         these Connector Types
     * @param  connectorMinPower  Optional parameter: Filter by Locations that have a Connector with
     *         at least this power output (in kW)
     * @param  authorizationMethods  Optional parameter: Filter by Locations that support the given
     *         Authorization Methods
     * @param  withOperatorName  Optional parameter: Return operator name in marker object (only for
     *         marker type Single ChargePoint)
     * @param  withMaxPower  Optional parameter: Return maximum power in kW across all locations
     *         grouped in this marker (disregarding availability)
     * @param  country  Optional parameter: Filter by Locations that are at least in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @param  excludeCountry  Optional parameter: Filter by Locations that are not in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @return    Returns the Response response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Response nearbyLocations(
            final UUID requestId,
            final double latitude,
            final double longitude,
            final Double limit,
            final String locationExternalId,
            final String evseId,
            final String evseExternalId,
            final String operatorName,
            final NearbyLocationsEvseStatusEnum evseStatus,
            final NearbyLocationsConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final NearbyLocationsAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final Boolean withMaxPower,
            final List<String> country,
            final List<String> excludeCountry) throws ApiException, IOException {
        return prepareNearbyLocationsRequest(requestId, latitude, longitude, limit,
                locationExternalId, evseId, evseExternalId, operatorName, evseStatus,
                connectorTypes, connectorMinPower, authorizationMethods, withOperatorName,
                withMaxPower, country, excludeCountry).execute();
    }

    /**
     * This API provides the list of all nearby Shell Recharge locations based on the latitude and
     * longitude provided in the request. The list includes all Shell Recharge network and all sites
     * available through our roaming partners. The end point provides the details such as the exact
     * location/address of the site along with the up-to-date status information of all the charging
     * units in the site. Supported Search Options * Based on latitude and longitude of the
     * location. (Mandatory) * Based on status of the Charging units. Eg : Available or Occupied *
     * Based on available connector types. * Based on minimum Power output (in kW) available.
     * @param  requestId  Required parameter: RequestId must be unique identifier value that can be
     *         used by the consumer to correlate each request /response .&lt;br&gt;Format.&lt;br&gt;
     *         Its canonical textual representation, the 16 octets of a UUID are represented as 32
     *         hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the
     *         form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4
     *         hyphens) &lt;br&gt;
     * @param  latitude  Required parameter: Latitude to get Shell Recharge Locations nearby
     * @param  longitude  Required parameter: Longitude to get Shell Recharge Locations nearby
     * @param  limit  Optional parameter: Maximum number of Locations to retrieve
     * @param  locationExternalId  Optional parameter: Filter by Locations with the given externalId
     *         Identifier as given by the Shell Recharge Operator, unique for that Operator
     * @param  evseId  Optional parameter: Filter by Locations that have an Evse with the given Evse
     *         Id
     * @param  evseExternalId  Optional parameter: Filter by Locations that have an Evse with the
     *         given External Id Identifier of the Evse as given by the Operator, unique for that
     *         Operator
     * @param  operatorName  Optional parameter: Filter by Locations that have the given operator
     * @param  evseStatus  Optional parameter: Filter by Locations that have the given status
     * @param  connectorTypes  Optional parameter: Filter by Locations that have Connectors with
     *         these Connector Types
     * @param  connectorMinPower  Optional parameter: Filter by Locations that have a Connector with
     *         at least this power output (in kW)
     * @param  authorizationMethods  Optional parameter: Filter by Locations that support the given
     *         Authorization Methods
     * @param  withOperatorName  Optional parameter: Return operator name in marker object (only for
     *         marker type Single ChargePoint)
     * @param  withMaxPower  Optional parameter: Return maximum power in kW across all locations
     *         grouped in this marker (disregarding availability)
     * @param  country  Optional parameter: Filter by Locations that are at least in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @param  excludeCountry  Optional parameter: Filter by Locations that are not in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @return    Returns the Response response from the API call
     */
    public CompletableFuture<Response> nearbyLocationsAsync(
            final UUID requestId,
            final double latitude,
            final double longitude,
            final Double limit,
            final String locationExternalId,
            final String evseId,
            final String evseExternalId,
            final String operatorName,
            final NearbyLocationsEvseStatusEnum evseStatus,
            final NearbyLocationsConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final NearbyLocationsAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final Boolean withMaxPower,
            final List<String> country,
            final List<String> excludeCountry) {
        try { 
            return prepareNearbyLocationsRequest(requestId, latitude, longitude, limit, locationExternalId,
            evseId, evseExternalId, operatorName, evseStatus, connectorTypes, connectorMinPower,
            authorizationMethods, withOperatorName, withMaxPower, country,
            excludeCountry).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for nearbyLocations.
     */
    private ApiCall<Response, ApiException> prepareNearbyLocationsRequest(
            final UUID requestId,
            final double latitude,
            final double longitude,
            final Double limit,
            final String locationExternalId,
            final String evseId,
            final String evseExternalId,
            final String operatorName,
            final NearbyLocationsEvseStatusEnum evseStatus,
            final NearbyLocationsConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final NearbyLocationsAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final Boolean withMaxPower,
            final List<String> country,
            final List<String> excludeCountry) throws IOException {
        return new ApiCall.Builder<Response, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/locations/v1/ev/nearby")
                        .queryParam(param -> param.key("latitude")
                                .value(latitude).isRequired(false))
                        .queryParam(param -> param.key("longitude")
                                .value(longitude).isRequired(false))
                        .queryParam(param -> param.key("limit")
                                .value((limit != null) ? limit : 25d).isRequired(false))
                        .queryParam(param -> param.key("locationExternalId")
                                .value(locationExternalId).isRequired(false))
                        .queryParam(param -> param.key("evseId")
                                .value(evseId).isRequired(false))
                        .queryParam(param -> param.key("evseExternalId")
                                .value(evseExternalId).isRequired(false))
                        .queryParam(param -> param.key("operatorName")
                                .value(operatorName).isRequired(false))
                        .queryParam(param -> param.key("evseStatus")
                                .value((evseStatus != null) ? evseStatus.value() : null).isRequired(false))
                        .queryParam(param -> param.key("connectorTypes")
                                .value((connectorTypes != null) ? connectorTypes.value() : null).isRequired(false))
                        .queryParam(param -> param.key("connectorMinPower")
                                .value(connectorMinPower).isRequired(false))
                        .queryParam(param -> param.key("authorizationMethods")
                                .value((authorizationMethods != null) ? authorizationMethods.value() : null).isRequired(false))
                        .queryParam(param -> param.key("withOperatorName")
                                .value(withOperatorName).isRequired(false))
                        .queryParam(param -> param.key("withMaxPower")
                                .value(withMaxPower).isRequired(false))
                        .queryParam(param -> param.key("country")
                                .value(country).isRequired(false))
                        .queryParam(param -> param.key("excludeCountry")
                                .value(excludeCountry).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(String.valueOf(requestId)).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Response.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new BadRequestException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid authentication credentials for the target resource.",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("Location Not Found",
                                (reason, context) -> new NotFoundException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The Request reached maximum allocated rate limit",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal Server error",
                                (reason, context) -> new InternalServerErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service unavailable",
                                (reason, context) -> new ServiceunavailableException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API, when given a set of bounds on the geographical front (East,West, North, South) will
     * return a set of Markers that fall within the requested bounds. The API will automatically
     * group locations at the same position on the map into one Marker. The API also provide further
     * search options to filter the result set. * Based on status of the Charging units. Eg :
     * Available or Occupied * Based on available connector types. * Based on minimum Power output
     * (in kW) available.
     * @param  requestId  Required parameter: RequestId must be unique identifier value that can be
     *         used by the consumer to correlate each request /response .&lt;br&gt;Format.&lt;br&gt;
     *         Its canonical textual representation, the 16 octets of a UUID are represented as 32
     *         hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the
     *         form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4
     *         hyphens) &lt;br&gt;
     * @param  west  Required parameter: Longitude of the western bound to get the Shell Recharge
     *         Locations
     * @param  south  Required parameter: Latitude of the southern bound to get the Shell Recharge
     *         Locations
     * @param  east  Required parameter: Longitude of the eastern bound to get the Shell Recharge
     *         Locations
     * @param  north  Required parameter: Latitude of the northern bound to get the Shell Recharge
     *         Locations
     * @param  zoom  Required parameter: Zoom level to show ex: (1: World, 5: Landmass/continent,
     *         10: City, 15: Streets, 20: Buildings)
     * @param  evseStatus  Optional parameter: Filter by Locations that have the given status
     * @param  connectorTypes  Optional parameter: Filter by Locations that have Connectors with the
     *         set of Connector Types
     * @param  connectorMinPower  Optional parameter: Filter by Locations that have a Connector with
     *         at least this power output (in kW)
     * @param  authorizationMethods  Optional parameter: Filter by Locations that support the given
     *         Authorization Methods
     * @param  withOperatorName  Optional parameter: Return operator name in marker object (only for
     *         marker type SingleChargePoint)
     * @param  withMaxPower  Optional parameter: Return maximum power in kW across all locations
     *         grouped in this marker (disregarding availability)
     * @param  locationExternalId  Optional parameter: Filter by Locations with the given
     *         externalId. (Unique Location externalID provided by Shell Recharge)
     * @param  evseId  Optional parameter: Filter by Locations that have an Evse with the given Evse
     *         Id
     * @param  evseExternalId  Optional parameter: Filter by Locations that have an Evse with the
     *         given External Id Identifier of the Evse as given by the Operator, unique for that
     *         Operator
     * @param  operatorName  Optional parameter: Filter by Locations that have the given operator
     * @param  country  Optional parameter: Filter by Locations that are at least in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @param  excludeCountry  Optional parameter: Filter by Locations that are not in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @return    Returns the SingleLocationMarkerResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SingleLocationMarkerResponse locationsMarkers(
            final UUID requestId,
            final double west,
            final double south,
            final double east,
            final double north,
            final String zoom,
            final LocationsMarkersEvseStatusEnum evseStatus,
            final LocationsMarkersConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final LocationsMarkersAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final Boolean withMaxPower,
            final String locationExternalId,
            final String evseId,
            final String evseExternalId,
            final String operatorName,
            final List<String> country,
            final List<String> excludeCountry) throws ApiException, IOException {
        return prepareLocationsMarkersRequest(requestId, west, south, east, north, zoom, evseStatus,
                connectorTypes, connectorMinPower, authorizationMethods, withOperatorName,
                withMaxPower, locationExternalId, evseId, evseExternalId, operatorName, country,
                excludeCountry).execute();
    }

    /**
     * This API, when given a set of bounds on the geographical front (East,West, North, South) will
     * return a set of Markers that fall within the requested bounds. The API will automatically
     * group locations at the same position on the map into one Marker. The API also provide further
     * search options to filter the result set. * Based on status of the Charging units. Eg :
     * Available or Occupied * Based on available connector types. * Based on minimum Power output
     * (in kW) available.
     * @param  requestId  Required parameter: RequestId must be unique identifier value that can be
     *         used by the consumer to correlate each request /response .&lt;br&gt;Format.&lt;br&gt;
     *         Its canonical textual representation, the 16 octets of a UUID are represented as 32
     *         hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the
     *         form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4
     *         hyphens) &lt;br&gt;
     * @param  west  Required parameter: Longitude of the western bound to get the Shell Recharge
     *         Locations
     * @param  south  Required parameter: Latitude of the southern bound to get the Shell Recharge
     *         Locations
     * @param  east  Required parameter: Longitude of the eastern bound to get the Shell Recharge
     *         Locations
     * @param  north  Required parameter: Latitude of the northern bound to get the Shell Recharge
     *         Locations
     * @param  zoom  Required parameter: Zoom level to show ex: (1: World, 5: Landmass/continent,
     *         10: City, 15: Streets, 20: Buildings)
     * @param  evseStatus  Optional parameter: Filter by Locations that have the given status
     * @param  connectorTypes  Optional parameter: Filter by Locations that have Connectors with the
     *         set of Connector Types
     * @param  connectorMinPower  Optional parameter: Filter by Locations that have a Connector with
     *         at least this power output (in kW)
     * @param  authorizationMethods  Optional parameter: Filter by Locations that support the given
     *         Authorization Methods
     * @param  withOperatorName  Optional parameter: Return operator name in marker object (only for
     *         marker type SingleChargePoint)
     * @param  withMaxPower  Optional parameter: Return maximum power in kW across all locations
     *         grouped in this marker (disregarding availability)
     * @param  locationExternalId  Optional parameter: Filter by Locations with the given
     *         externalId. (Unique Location externalID provided by Shell Recharge)
     * @param  evseId  Optional parameter: Filter by Locations that have an Evse with the given Evse
     *         Id
     * @param  evseExternalId  Optional parameter: Filter by Locations that have an Evse with the
     *         given External Id Identifier of the Evse as given by the Operator, unique for that
     *         Operator
     * @param  operatorName  Optional parameter: Filter by Locations that have the given operator
     * @param  country  Optional parameter: Filter by Locations that are at least in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @param  excludeCountry  Optional parameter: Filter by Locations that are not in one of the
     *         given countries (specified using ISO 3166-1 alpha-3 codes)
     * @return    Returns the SingleLocationMarkerResponse response from the API call
     */
    public CompletableFuture<SingleLocationMarkerResponse> locationsMarkersAsync(
            final UUID requestId,
            final double west,
            final double south,
            final double east,
            final double north,
            final String zoom,
            final LocationsMarkersEvseStatusEnum evseStatus,
            final LocationsMarkersConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final LocationsMarkersAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final Boolean withMaxPower,
            final String locationExternalId,
            final String evseId,
            final String evseExternalId,
            final String operatorName,
            final List<String> country,
            final List<String> excludeCountry) {
        try { 
            return prepareLocationsMarkersRequest(requestId, west, south, east, north, zoom, evseStatus,
            connectorTypes, connectorMinPower, authorizationMethods, withOperatorName, withMaxPower,
            locationExternalId, evseId, evseExternalId, operatorName, country,
            excludeCountry).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for locationsMarkers.
     */
    private ApiCall<SingleLocationMarkerResponse, ApiException> prepareLocationsMarkersRequest(
            final UUID requestId,
            final double west,
            final double south,
            final double east,
            final double north,
            final String zoom,
            final LocationsMarkersEvseStatusEnum evseStatus,
            final LocationsMarkersConnectorTypesEnum connectorTypes,
            final Double connectorMinPower,
            final LocationsMarkersAuthorizationMethodsEnum authorizationMethods,
            final Boolean withOperatorName,
            final Boolean withMaxPower,
            final String locationExternalId,
            final String evseId,
            final String evseExternalId,
            final String operatorName,
            final List<String> country,
            final List<String> excludeCountry) throws IOException {
        return new ApiCall.Builder<SingleLocationMarkerResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/locations/v1/ev/markers")
                        .queryParam(param -> param.key("west")
                                .value(west).isRequired(false))
                        .queryParam(param -> param.key("south")
                                .value(south).isRequired(false))
                        .queryParam(param -> param.key("east")
                                .value(east).isRequired(false))
                        .queryParam(param -> param.key("north")
                                .value(north).isRequired(false))
                        .queryParam(param -> param.key("zoom")
                                .value(zoom))
                        .queryParam(param -> param.key("evseStatus")
                                .value((evseStatus != null) ? evseStatus.value() : null).isRequired(false))
                        .queryParam(param -> param.key("connectorTypes")
                                .value((connectorTypes != null) ? connectorTypes.value() : null).isRequired(false))
                        .queryParam(param -> param.key("connectorMinPower")
                                .value(connectorMinPower).isRequired(false))
                        .queryParam(param -> param.key("authorizationMethods")
                                .value((authorizationMethods != null) ? authorizationMethods.value() : null).isRequired(false))
                        .queryParam(param -> param.key("withOperatorName")
                                .value(withOperatorName).isRequired(false))
                        .queryParam(param -> param.key("withMaxPower")
                                .value(withMaxPower).isRequired(false))
                        .queryParam(param -> param.key("locationExternalId")
                                .value(locationExternalId).isRequired(false))
                        .queryParam(param -> param.key("evseId")
                                .value(evseId).isRequired(false))
                        .queryParam(param -> param.key("evseExternalId")
                                .value(evseExternalId).isRequired(false))
                        .queryParam(param -> param.key("operatorName")
                                .value(operatorName).isRequired(false))
                        .queryParam(param -> param.key("country")
                                .value(country).isRequired(false))
                        .queryParam(param -> param.key("excludeCountry")
                                .value(excludeCountry).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(String.valueOf(requestId)).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SingleLocationMarkerResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new BadRequestException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid authentication credentials for the target resource.",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("Location Not Found",
                                (reason, context) -> new NotFoundException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The Request reached maximum allocated rate limit",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal server error",
                                (reason, context) -> new InternalServerErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service unavailable",
                                (reason, context) -> new ServiceunavailableException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}